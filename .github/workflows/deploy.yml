name: Deploy to syr1-vps

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    env:
      VPS_HOST: ${{ secrets.VPS_HOST }}
      VPS_USER: ${{ secrets.VPS_USER }}
      DEPLOY_DIR: /root/watan
    steps:
      # 0) تشخيص: تأكد أن المفتاح وصل من GitHub (لا نطبع المحتوى)
      - name: Check SSH key length (no print)
        shell: bash
        env:
          K: ${{ secrets.VPS_SSH_KEY }}
        run: |
          echo "SSH key length: ${#K} bytes"

      # 1) تحقق من وجود الأسرار الأساسية وطولها
      - name: Validate required secrets (early)
        shell: bash
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
        run: |
          set -e
          missing=0
          for v in VPS_HOST VPS_USER; do
            if [ -z "${!v}" ]; then echo "Missing env $v"; missing=1; fi
          done
            
          for v in DATABASE_URL REDIS_URL JWT_SECRET VPS_SSH_KEY; do
            eval val="\${$v}"
            if [ -z "$val" ]; then echo "Missing secret $v"; missing=1; fi
          done
          if [ $missing -ne 0 ]; then exit 1; fi
          echo "Lengths -> DB: $(printf %s "${DATABASE_URL}" | wc -c) REDIS: $(printf %s "${REDIS_URL}" | wc -c) JWT: $(printf %s "${JWT_SECRET}" | wc -c) KEY: $(printf %s "${VPS_SSH_KEY}" | wc -c)"

      # 2) Checkout الكود (يدعم submodules عند الحاجة)
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 3) Sanity git
      - name: Sanity git
        shell: bash
        run: |
          set -euxo pipefail
          git --version
          git rev-parse HEAD
          git status --short || true

      # 4) تحميل مفتاح SSH
      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      # 5) إضافة المضيف و اختبار الاتصال
      - name: Add VPS host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "$VPS_HOST" >> ~/.ssh/known_hosts

      - name: Verify SSH connectivity
        shell: bash
        run: |
          set -euxo pipefail
          ssh -o BatchMode=yes -o ConnectTimeout=10 "$VPS_USER@$VPS_HOST" 'echo SSH_OK'

      - name: Upload project to VPS (tar over SSH)
        run: |
          ssh ${VPS_USER}@${VPS_HOST} "mkdir -p ${DEPLOY_DIR}"
          tar cz --exclude='.git' . | ssh ${VPS_USER}@${VPS_HOST} "tar xz -C ${DEPLOY_DIR}"

      - name: Create .env locally
        shell: bash
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          PUBLIC_TENANT_BASE_DOMAIN: ${{ secrets.PUBLIC_TENANT_BASE_DOMAIN }}
        run: |
          set -e
          PTBD="${PUBLIC_TENANT_BASE_DOMAIN:-syrz1.com}"
          mkdir -p .deploy_tmp
          {
            echo "DATABASE_URL=${DATABASE_URL}"
            echo "REDIS_URL=${REDIS_URL}"
            echo "JWT_SECRET=${JWT_SECRET}"
            echo "PUBLIC_TENANT_BASE_DOMAIN=${PTBD}"
            echo "AUTO_MIGRATIONS=true"
            echo "HOST=0.0.0.0"
            echo "PORT=3000"
            echo "INITIAL_ROOT_EMAIL=owner@example.com"
            echo "INITIAL_ROOT_PASSWORD=ChangeMe123!"
            echo "BOOTSTRAP_ENABLED=true"
            echo "NEXT_PUBLIC_API_URL=http://api.syrz1.com/api"
          } > .deploy_tmp/.env

      - name: Upload .env to VPS
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          DEPLOY_DIR: /root/watan
        run: |
          set -e
          ssh "$VPS_USER@$VPS_HOST" "mkdir -p \"$DEPLOY_DIR\""
          scp -o StrictHostKeyChecking=no .deploy_tmp/.env "$VPS_USER@$VPS_HOST:$DEPLOY_DIR/.env"
          rm -rf .deploy_tmp

      - name: Pre-compose diagnostics
        run: |
          set -euxo pipefail
          ssh ${VPS_USER}@${VPS_HOST} "docker --version || true"
          ssh ${VPS_USER}@${VPS_HOST} "docker compose version || true"
          ssh ${VPS_USER}@${VPS_HOST} "ls -al ${DEPLOY_DIR} || true"
          ssh ${VPS_USER}@${VPS_HOST} "cd ${DEPLOY_DIR} && head -n 50 docker-compose.yml || sed -n '1,80p' docker-compose.yml"
          ssh ${VPS_USER}@${VPS_HOST} "cd ${DEPLOY_DIR} && grep -n 'image:' docker-compose.yml || true"
          ssh ${VPS_USER}@${VPS_HOST} "cd ${DEPLOY_DIR} && docker compose config --quiet" || echo 'compose config had issues'

      - name: Docker compose build & up
        run: |
          set -euo pipefail
          # Prefer Docker Compose v2 plugin; fallback to legacy docker-compose only if plugin absent
          if ssh ${VPS_USER}@${VPS_HOST} "docker compose version >/dev/null 2>&1"; then
            COMPOSE_CMD="docker compose"
          elif ssh ${VPS_USER}@${VPS_HOST} "command -v docker-compose >/dev/null 2>&1"; then
            COMPOSE_CMD="docker-compose"
          else
            echo "No docker compose command found" >&2; exit 1
          fi
          # Clean previous stack to avoid legacy volume merge bug (KeyError: 'ContainerConfig')
          ssh ${VPS_USER}@${VPS_HOST} "cd ${DEPLOY_DIR} && $COMPOSE_CMD down --remove-orphans || true"
          ssh ${VPS_USER}@${VPS_HOST} "cd ${DEPLOY_DIR} && $COMPOSE_CMD build --pull"
          ssh ${VPS_USER}@${VPS_HOST} "cd ${DEPLOY_DIR} && $COMPOSE_CMD up -d"

      - name: Show containers
        run: |
          ssh ${VPS_USER}@${VPS_HOST} "cd ${DEPLOY_DIR} && docker compose ps"

      - name: Health check frontend & backend
        run: |
          echo '--- Frontend (syrz1.com) ---'
          ssh ${VPS_USER}@${VPS_HOST} "curl -I -s http://syrz1.com | head -n 15" || true
          echo '\n--- Backend (api.syrz1.com/api/health) ---'
          ssh ${VPS_USER}@${VPS_HOST} "curl -i -s http://api.syrz1.com/api/health" || true

      - name: Collect logs (last 30 lines per service)
        run: |
          set -e
          > logs.txt
          for svc in backend frontend worker nginx; do
            echo "===== $svc =====" | tee -a logs.txt
            ssh ${VPS_USER}@${VPS_HOST} "docker logs --tail=30 watan-$svc" 2>&1 | tee -a logs.txt || echo "(failed to fetch $svc logs)" | tee -a logs.txt
            echo "" >> logs.txt
          done
          echo "### Deployment Log Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          sed 's/^/    /' logs.txt >> $GITHUB_STEP_SUMMARY

      - name: Upload raw logs artifact (optional)
        uses: actions/upload-artifact@v4
        with:
          name: deploy-logs
          path: logs.txt
