# ملخص مشكلة Loop Detection

## المشكلة باختصار
- تم رصد حلقة توجيه لا نهائية بين مستأجرين (Alsham ⇄ ShamTech) عند إنشاء طلبات متسلسلة.
- يظهر ذلك حين يساوي `order.id` قيمة `order.external_order_id`، ما يعني أن الطلب يشير إلى نفسه.

## سبب التعطل
- كود اكتشاف الحلقات مضاف في ثلاث طبقات لكنه لا يعمل لأن خادم Django يعمل بنسخة قديمة من الذاكرة.
- بعد تعديل الملفات لم يُعد تشغيل السيرفر، فاستمر السلوك القديم دون رفض الطلبات الدائرية.

## طبقات الحماية المضافة
- `apps/users/client_api_orders_views.py`: يمنع إنشاء الطلب ويعيد 422 مع خطأ `LOOP_DETECTED` إذا كان المستأجر الحالي ضمن سلسلة الطلبات.
- `apps/providers/adapters/internal.py`: يحول الاستجابة 422 إلى حالة `manual_required` ليتم التعامل معها داخلياً.
- `apps/orders/services.py`: يوقف الـ auto-dispatch، يعيد الطلب إلى حالة `pending/manual_required`، ويمسح `provider_id` لتظهر الحالة "Manual" في الواجهة.

## إصلاح جانبي في نفس السياق
- تمت إزالة السطر الذي كان يكتب `order.provider_id = "CHAIN_FORWARD"` في `apps/orders/services.py` حتى يبقى معرف المزود الأصلي ولا يظهر UUID عشوائي للمستخدم.

## المطلوب حالياً
- إيقاف خادم Django (`Ctrl+C`) ثم تشغيله مجدداً بـ `python manage.py runserver` ليتم تحميل منطق الحماية الجديد.
- اختبار إنشاء طلب جديد (مثلاً للمستخدم 555) للتأكد من أن ShamTech يستلم الحالة `manual_required` عند محاولة إعادة التوجيه إلى Alsham.

## حالة البيانات
- تم استخدام `fix_444_loop.py` لتنظيف الطلبات القديمة المتأثرة؛ حالياً لا توجد طلبات نشطة في حلقة لكن يلزم التحقق بعد إعادة التشغيل.

**تاريخ التحديث:** 22 أكتوبر 2025
