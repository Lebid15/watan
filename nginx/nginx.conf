upstream frontend_upstream { server frontend:3001; }
upstream backend_upstream  { server backend:3000; }

# === Maintenance Mode maps (included from mounted file) ===
include /etc/nginx/conf.d/maintenance.conf;

# ==== Dynamic CORS origin mapping (restrict to wtn4.com + subdomains) ====
# Accept http/https origins that end with wtn4.com (optionally one or more subdomain labels)
# Anything else => empty (no CORS header emitted)
map $http_origin $cors_allow_origin {
  ~^https?://([A-Za-z0-9-]+\.)?wtn4\.com$  $http_origin;
  default                                   "";
}

# Extract bare host (subdomain.wtn4.com) from Origin for multi-tenant header
map $http_origin $tenant_origin_host {
  ~^https?://([^/]+)$  $1;
  default              "";
}

# Real IP (Cloudflare) – this file is included inside the main http{} so directives are valid
real_ip_header CF-Connecting-IP;
set_real_ip_from 0.0.0.0/0;
map $http_upgrade $connection_upgrade { default upgrade; '' close; }

# Frontend HTTP (optional – can redirect to HTTPS later if needed)
server {
  listen 80;
  listen [::]:80;
  # Include root, www, and any non-api subdomain (tenant) *.wtn4.com
  server_name wtn4.com www.wtn4.com ~^(?!(api)\.)[A-Za-z0-9-]+\.wtn4\.com$;
  # Maintenance guard (HTTP frontend)
  error_page 503 /maintenance.html;
  set $serve_maintenance 0;
  if ($maintenance_mode = on) { set $serve_maintenance 1; }
  if ($is_maint_exempt = 1)   { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  if ($serve_maintenance = 1) { return 503; }
  location = /maintenance.html { root /usr/share/nginx/html; add_header Retry-After 600 always; add_header Cache-Control "no-store" always; }
  # Public client OpenAPI (exact match) – keep before prefix block
  location = /client/api/openapi.json {
    proxy_pass http://backend_upstream/client/api/openapi.json;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    add_header Access-Control-Allow-Origin * always;
    add_header Cache-Control "public, max-age=60";
  }

  # Proxy all Client API calls (unprefixed) to backend global /api prefix
  location ^~ /client/api/ {
    # Map /client/api/...  -> backend /api/client/api/...
    proxy_pass http://backend_upstream/api/client/api/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    add_header X-Debug-Upstream backend-client-api always;
  }
  # --- INTERNAL NEXT API (served by frontend, not backend) ---
  # Critical user profile route must hit backend (avoid Next.js handling /api/users/* paths)
  location = /api/users/profile-with-currency { proxy_pass http://backend_upstream; proxy_set_header X-Tenant-Host $host; }
  location = /api/me { proxy_pass http://frontend_upstream; }
  location = /api/auth/logout { proxy_pass http://frontend_upstream; }
  location = /api/auth/sync { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-orders-count { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-deposits-count { proxy_pass http://frontend_upstream; }
  # Fallback: proxy /api/* to backend if api.wtn4.com subdomain unreachable
  location ^~ /api/ {
    # Preserve original /api/... path so Nest global prefix still matches
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  # Pass tenant host for backend multi-tenant resolution (was missing here)
  proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
  add_header X-Debug-Upstream backend always;
  }
  location / {
    proxy_pass http://frontend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    # Pass tenant hint header (host without port)
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }
}

# Backend API HTTP
server {
  listen 80;
  listen [::]:80;
  server_name api.wtn4.com;
  # Maintenance guard (HTTP api)
  error_page 503 /maintenance.html;
  set $serve_maintenance 0;
  if ($maintenance_mode = on) { set $serve_maintenance 1; }
  if ($is_maint_exempt = 1)   { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  if ($serve_maintenance = 1) { return 503; }
  location = /maintenance.html { root /usr/share/nginx/html; add_header Retry-After 600 always; add_header Cache-Control "no-store" always; }
  # Hide upstream CORS headers to avoid duplication (backend also sets them)
  proxy_hide_header Access-Control-Allow-Origin;
  proxy_hide_header Access-Control-Allow-Credentials;
  proxy_hide_header Access-Control-Allow-Methods;
  proxy_hide_header Access-Control-Allow-Headers;
  proxy_hide_header Access-Control-Expose-Headers;
  proxy_hide_header Access-Control-Max-Age;
  # --- Global CORS headers (HTTP) ---
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
  add_header Access-Control-Expose-Headers "Content-Disposition" always;
  add_header Access-Control-Max-Age 86400 always;
  add_header Vary Origin always;
  # (Debug headers removed)
  location / {
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  # Pass tenant hint extracted from Origin (needed for new subdomains)
  proxy_set_header X-Tenant-Host $tenant_origin_host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;

    client_max_body_size 15m;
    proxy_request_buffering off;
    proxy_connect_timeout 30s;
    proxy_send_timeout 120s;
    proxy_read_timeout 120s;
    send_timeout 120s;
    proxy_buffering on;
    proxy_buffers 16 16k;
    proxy_busy_buffers_size 24k;
  # Preflight short-circuit (server-level headers already attached)
  if ($request_method = OPTIONS) { return 204; }
  proxy_set_header Origin $http_origin;
  }
}

# Frontend HTTPS
server {
  listen 443 ssl;
  listen [::]:443 ssl;
  http2 on;
  # Include root, www, and any non-api subdomain (tenant) *.wtn4.com
  server_name wtn4.com www.wtn4.com ~^(?!(api)\.)[A-Za-z0-9-]+\.wtn4\.com$;
  # Maintenance guard (HTTPS frontend)
  error_page 503 /maintenance.html;
  set $serve_maintenance 0;
  if ($maintenance_mode = on) { set $serve_maintenance 1; }
  if ($is_maint_exempt = 1)   { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  if ($serve_maintenance = 1) { return 503; }
  location = /maintenance.html { root /usr/share/nginx/html; add_header Retry-After 600 always; add_header Cache-Control "no-store" always; }
  # Public client OpenAPI (HTTPS exact match)
  location = /client/api/openapi.json {
    proxy_pass http://backend_upstream/client/api/openapi.json;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    add_header Access-Control-Allow-Origin * always;
    add_header Cache-Control "public, max-age=60";
  }

  # Proxy all Client API calls (HTTPS)
  location ^~ /client/api/ {
    proxy_pass http://backend_upstream/api/client/api/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    add_header X-Debug-Upstream backend-client-api always;
  }
  # --- INTERNAL NEXT API (served by frontend, not backend) ---
  location = /api/users/profile-with-currency { proxy_pass http://backend_upstream; proxy_set_header X-Tenant-Host $host; }
  location = /api/me { proxy_pass http://frontend_upstream; }
  location = /api/auth/logout { proxy_pass http://frontend_upstream; }
  location = /api/auth/sync { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-orders-count { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-deposits-count { proxy_pass http://frontend_upstream; }
  ssl_certificate     /etc/nginx/certs/origin.pem;
  ssl_certificate_key /etc/nginx/certs/origin.key;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;
  # Fallback: proxy /api/* to backend if api.wtn4.com subdomain unreachable
  location ^~ /api/ {
    # Preserve original /api/... path so Nest global prefix still matches
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  # Pass tenant host for backend multi-tenant resolution (was missing here)
  proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
  add_header X-Debug-Upstream backend always;
  }
  location / {
    proxy_pass http://frontend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }
}

# Backend API HTTPS
server {
  listen 443 ssl;
  listen [::]:443 ssl;
  http2 on;
  server_name api.wtn4.com;
  # Maintenance guard (HTTPS api)
  error_page 503 /maintenance.html;
  set $serve_maintenance 0;
  if ($maintenance_mode = on) { set $serve_maintenance 1; }
  if ($is_maint_exempt = 1)   { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  if ($serve_maintenance = 1) { return 503; }
  location = /maintenance.html { root /usr/share/nginx/html; add_header Retry-After 600 always; add_header Cache-Control "no-store" always; }
  ssl_certificate     /etc/nginx/certs/origin.pem;
  ssl_certificate_key /etc/nginx/certs/origin.key;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;
  # Hide upstream CORS headers to avoid duplication (backend also sets them)
  proxy_hide_header Access-Control-Allow-Origin;
  proxy_hide_header Access-Control-Allow-Credentials;
  proxy_hide_header Access-Control-Allow-Methods;
  proxy_hide_header Access-Control-Allow-Headers;
  proxy_hide_header Access-Control-Expose-Headers;
  proxy_hide_header Access-Control-Max-Age;
  # --- Global CORS headers (HTTPS) ---
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
  add_header Access-Control-Expose-Headers "Content-Disposition" always;
  add_header Access-Control-Max-Age 86400 always;
  add_header Vary Origin always;
  # (Debug headers removed)
  location / {
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  proxy_set_header X-Tenant-Host $tenant_origin_host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
    proxy_connect_timeout 30s;
    proxy_send_timeout 120s;
    proxy_read_timeout 120s;
    send_timeout 120s;
    proxy_buffering on;
    proxy_buffers 16 16k;
    proxy_busy_buffers_size 24k;
  if ($request_method = OPTIONS) { return 204; }
  proxy_set_header Origin $http_origin;
  }
}

# Fallback unknown hosts
server {
  listen 80 default_server;
  return 444;
}
