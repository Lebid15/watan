upstream frontend_upstream { server watan-frontend:3001; }
upstream backend_upstream  { server watan-backend:3000; }
upstream djangoo_upstream  { server watan-djangoo:8000; }

# === Maintenance Mode (global map + per-server switch) ===
include /etc/nginx/conf.d/maintenance.conf;   # defines map $maintenance_switch -> $maintenance_mode

# ==== Dynamic CORS origin mapping (restrict to wtn4.com + subdomains) ====
# Accept http/https origins that end with wtn4.com (optionally one or more subdomain labels)
# Anything else => empty (no CORS header emitted)
map $http_origin $cors_allow_origin {
  ~^https?://([A-Za-z0-9-]+\.)?wtn4\.com$  $http_origin;
  default                                   "";
}

# Extract bare host (subdomain.wtn4.com) from Origin for multi-tenant header
map $http_origin $tenant_origin_host {
  ~^https?://([^/]+)$  $1;
  default              "";
}

# Real IP (Cloudflare) – this file is included inside the main http{} so directives are valid
real_ip_header CF-Connecting-IP;
set_real_ip_from 0.0.0.0/0;
map $http_upgrade $connection_upgrade { default upgrade; '' close; }

# === Restrict maintenance to tenant subdomains only ===
# Root & platform domains (wtn4.com, www.wtn4.com, watan.games, www.watan.games, api.*) stay ONLINE even if maintenance_mode=on.
# Any other subdomain (not api|www) like store1.wtn4.com will receive maintenance page when maintenance_mode=on.
map $host $tenant_maint_target {
  default 0;
  wtn4.com          0;
  www.wtn4.com      0;
  watan.games       0;
  www.watan.games   0;
  api.wtn4.com      0;
  api.watan.games   0;
  ~^(?!(api|www)\.)[A-Za-z0-9-]+\.wtn4\.com$ 1;
}

# Frontend HTTP (optional – can redirect to HTTPS later if needed)
server {
  listen 80;
  listen [::]:80;
  # Include root, www, and any non-api subdomain (tenant) *.wtn4.com
  server_name wtn4.com www.wtn4.com watan.games www.watan.games ~^(?!(api)\.)[A-Za-z0-9-]+\.wtn4\.com$;
  include /opt/nginx-shared/mode.conf; # defines: set $maintenance_switch on|off
  # Force dev exemptions early so maintenance guard never blocks them even if map fails
  if ($uri ~ ^/api/dev/) { set $is_maint_exempt 1; }
  if ($uri ~ ^/dev(/|$)) { set $is_maint_exempt 1; }
  # Maintenance guard (HTTP frontend)
  # Only redirect deliberate 503 (our maintenance trigger) to @maintenance
  error_page 503 @maintenance;
  # No proxy_intercept_errors so upstream 500/502 are not masked as maintenance
  set $serve_maintenance 0;
  # Apply maintenance only if global mode on AND host is a tenant store subdomain
  if ($maintenance_mode != off) { set $serve_maintenance $tenant_maint_target; }
  if ($is_maint_exempt_final = 1)   { set $serve_maintenance 0; }
  # Fallback if combined map variable not populated (defensive)
  if ($is_maint_exempt = 1) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  if ($http_x_maint_bypass ~* ^allow$) { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  # Explicit developer cookie bypass (in addition to map logic in maintenance.conf)
  if ($cookie_X_MAINT_DEV ~* ^allow$) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  # Exemptions now handled centrally by $is_maint_exempt map (maintenance.conf)
  if ($serve_maintenance = 1) { return 503; }
  # Custom maintenance internal location
  location @maintenance {
    internal;
    root /usr/share/nginx/html;
    add_header Cache-Control "no-store" always;
  # Ensure CORS headers present even during maintenance (preflight/login, etc.)
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
    try_files /maintenance.html =503;
  }
  add_header X-Maint-Mode $maintenance_mode always;
  add_header X-Maint-Exempt $is_maint_exempt always;
  add_header X-Maint-Exempt-Final $is_maint_exempt_final always;
  add_header X-Serve-Maint $serve_maintenance always;
  location = /maintenance.html { root /usr/share/nginx/html; }
  # Public client OpenAPI (exact match) – keep before prefix block
  location = /client/api/openapi.json {
    proxy_pass http://backend_upstream/client/api/openapi.json;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    add_header Access-Control-Allow-Origin * always;
    add_header Cache-Control "public, max-age=60";
  }

  # Developer helper: visiting /dev once sets maintenance bypass cookie so /login works without exposing it publicly
  # NOTE: /dev itself already exempt via maintenance.conf (root only), this does NOT open /login for normal users.
  location = /dev {
  # Set cookie for root + ALL subdomains by adding Domain=.wtn4.com so api.wtn4.com also receives it
  add_header Set-Cookie "X_MAINT_DEV=allow; Path=/; Max-Age=7200; Domain=.wtn4.com; HttpOnly; SameSite=Lax" always;
    proxy_pass http://frontend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }

  # Proxy all Client API calls (unprefixed) to backend global /api prefix
  location ^~ /client/api/ {
    # Map /client/api/...  -> backend /api/client/api/...
    proxy_pass http://backend_upstream/api/client/api/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    add_header X-Debug-Upstream backend-client-api always;
  }

  # Django parity API routing under /api-dj/** to djangoo
  location ^~ /api-dj/ {
    proxy_pass http://djangoo_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header Authorization $http_authorization;
    proxy_set_header api-token $http_api_token;
    proxy_set_header x-api-token $http_x_api_token;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
    add_header X-Debug-Upstream djangoo always;
  }
  # --- INTERNAL NEXT API (served by frontend, not backend) ---
  # Critical user profile route must hit backend (avoid Next.js handling /api/users/* paths)
  location = /api/users/profile-with-currency { proxy_pass http://backend_upstream; proxy_set_header X-Tenant-Host $host; }
  # Maintenance overlay state (Next.js API route)
  location = /api/dev/maintenance {
    proxy_pass http://frontend_upstream;
    add_header X-Debug-Upstream frontend always;
  }
  # Explicit dev maintenance backend endpoints
  location = /api/dev/maintenance-status {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  location = /api/dev/toggle-nginx-maint {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  location = /api/me { proxy_pass http://frontend_upstream; }
  location = /api/auth/logout { proxy_pass http://frontend_upstream; }
  location = /api/auth/sync { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-orders-count { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-deposits-count { proxy_pass http://frontend_upstream; }
  # Fallback: proxy /api/* to backend if api.wtn4.com subdomain unreachable
  location ^~ /api/ {
    # Preserve original /api/... path so Nest global prefix still matches
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  # Pass tenant host for backend multi-tenant resolution (was missing here)
  proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
  add_header X-Debug-Upstream backend always;
  }
  location / {
    proxy_pass http://frontend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    # Pass tenant hint header (host without port)
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }
}

# Backend API HTTP
server {
  listen 80;
  listen [::]:80;
  server_name api.wtn4.com api.watan.games;
  include /opt/nginx-shared/mode.conf;
  # Force dev exemptions early
  if ($uri ~ ^/api/dev/) { set $is_maint_exempt 1; }
  if ($uri ~ ^/dev(/|$)) { set $is_maint_exempt 1; }
  # Maintenance guard (HTTP api)
  error_page 503 @maintenance;
  set $serve_maintenance 0;
  if ($maintenance_mode != off) { set $serve_maintenance $tenant_maint_target; }
  if ($is_maint_exempt_final = 1)   { set $serve_maintenance 0; }
  if ($is_maint_exempt = 1) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  if ($http_x_maint_bypass ~* ^allow$) { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  # Explicit developer cookie bypass (in addition to map logic in maintenance.conf)
  if ($cookie_X_MAINT_DEV ~* ^allow$) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  # Exemptions now handled centrally by $is_maint_exempt map (maintenance.conf)
  if ($serve_maintenance = 1) { return 503; }
  location @maintenance {
    internal;
    root /usr/share/nginx/html;
    add_header Cache-Control "no-store" always;
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
    try_files /maintenance.html =503;
  }
  add_header X-Maint-Mode $maintenance_mode always;
  add_header X-Maint-Exempt $is_maint_exempt always;
  add_header X-Maint-Exempt-Final $is_maint_exempt_final always;
  add_header X-Serve-Maint $serve_maintenance always;
  location = /maintenance.html { root /usr/share/nginx/html; }
  # Next.js internal API routes under /api/dev should hit frontend
  location = /api/dev/maintenance {
    proxy_pass http://frontend_upstream;
    add_header X-Debug-Upstream frontend always;
  }
  location = /api/dev/maintenance-status {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  location = /api/dev/toggle-nginx-maint {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  # Hide upstream CORS headers to avoid duplication (backend also sets them)
  proxy_hide_header Access-Control-Allow-Origin;
  proxy_hide_header Access-Control-Allow-Credentials;
  proxy_hide_header Access-Control-Allow-Methods;
  proxy_hide_header Access-Control-Allow-Headers;
  proxy_hide_header Access-Control-Expose-Headers;
  proxy_hide_header Access-Control-Max-Age;
  # --- Global CORS headers (HTTP) ---
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
  add_header Access-Control-Expose-Headers "Content-Disposition" always;
  add_header Access-Control-Max-Age 86400 always;
  add_header Vary Origin always;
  # (Debug headers removed)
  # Explicit CORS-preflight + login endpoint handling (HTTP)
  location = /api/auth/login {
    # Handle preflight explicitly before proxying
    if ($request_method = OPTIONS) {
      add_header Access-Control-Allow-Origin $cors_allow_origin always;
      add_header Access-Control-Allow-Credentials true always;
      add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
      add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
      add_header Access-Control-Max-Age 86400 always;
      add_header Vary Origin always;
      add_header X-Debug-CORS "login-preflight-http" always;
      return 204;
    }
  # IMPORTANT: Because this location defines add_header, parent server add_header directives are NOT inherited.
  # Re-declare full CORS headers for the POST (non-OPTIONS) response.
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
  add_header Access-Control-Expose-Headers "Content-Disposition" always;
  add_header Access-Control-Max-Age 86400 always;
  add_header Vary Origin always;
  add_header X-Debug-CORS "login-post-http" always;
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Tenant-Host $tenant_origin_host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }
  location / {
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  # Pass tenant hint extracted from Origin (needed for new subdomains)
  proxy_set_header X-Tenant-Host $tenant_origin_host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;

    client_max_body_size 15m;
    proxy_request_buffering off;
    proxy_connect_timeout 30s;
    proxy_send_timeout 120s;
    proxy_read_timeout 120s;
    send_timeout 120s;
    proxy_buffering on;
    proxy_buffers 16 16k;
    proxy_busy_buffers_size 24k;
  # Preflight short-circuit (server-level headers already attached)
  if ($request_method = OPTIONS) { return 204; }
  proxy_set_header Origin $http_origin;
  }
}

# Frontend HTTPS
server {
  listen 443 ssl;
  listen [::]:443 ssl;
  http2 on;
  # Include root, www, and any non-api subdomain (tenant) *.wtn4.com
  server_name wtn4.com www.wtn4.com watan.games www.watan.games ~^(?!(api)\.)[A-Za-z0-9-]+\.wtn4\.com$;
  include /opt/nginx-shared/mode.conf;
  # --- Security Headers (Frontend HTTPS) ---
  add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
  add_header Referrer-Policy "strict-origin-when-cross-origin" always;
  add_header Permissions-Policy "camera=(), geolocation=(), microphone=()" always;
  add_header X-Frame-Options "SAMEORIGIN" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-XSS-Protection "0" always; # modern browsers ignore; explicitly disabled to avoid false sense
  # NOTE: CSP currently relaxed due to potential inline scripts; tighten later with nonces
  add_header Content-Security-Policy "default-src 'self' https: data: 'unsafe-inline'; frame-ancestors 'self'; object-src 'none'; base-uri 'self';" always;
  # Force dev exemptions early
  if ($uri ~ ^/api/dev/) { set $is_maint_exempt 1; }
  if ($uri ~ ^/dev(/|$)) { set $is_maint_exempt 1; }
  # Maintenance guard (HTTPS frontend)
  error_page 503 @maintenance;
  set $serve_maintenance 0;
  if ($maintenance_mode != off) { set $serve_maintenance $tenant_maint_target; }
  if ($is_maint_exempt_final = 1)   { set $serve_maintenance 0; }
  if ($is_maint_exempt = 1) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  if ($http_x_maint_bypass ~* ^allow$) { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  # Explicit developer cookie bypass (in addition to map logic in maintenance.conf)
  if ($cookie_X_MAINT_DEV ~* ^allow$) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  # Exemptions now handled centrally by $is_maint_exempt map (maintenance.conf)
  if ($serve_maintenance = 1) { return 503; }
  location @maintenance {
    internal;
    root /usr/share/nginx/html;
    add_header Cache-Control "no-store" always;
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
    try_files /maintenance.html =503;
  }
  add_header X-Maint-Mode $maintenance_mode always;
  add_header X-Maint-Exempt $is_maint_exempt always;
  add_header X-Maint-Exempt-Final $is_maint_exempt_final always;
  add_header X-Serve-Maint $serve_maintenance always;
  location = /maintenance.html { root /usr/share/nginx/html; }
  # Public client OpenAPI (HTTPS exact match)
  location = /client/api/openapi.json {
    proxy_pass http://backend_upstream/client/api/openapi.json;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    add_header Access-Control-Allow-Origin * always;
    add_header Cache-Control "public, max-age=60";
  }

  # Developer helper: set bypass cookie at /dev (HTTPS) allowing /login during maintenance for dev only
  location = /dev {
  # Secure cookie + cross-subdomain Domain so backend (api.*) also gets bypass
  add_header Set-Cookie "X_MAINT_DEV=allow; Path=/; Max-Age=7200; Domain=.wtn4.com; HttpOnly; Secure; SameSite=Lax" always;
    proxy_pass http://frontend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }

  # Proxy all Client API calls (HTTPS)
  location ^~ /client/api/ {
    proxy_pass http://backend_upstream/api/client/api/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    add_header X-Debug-Upstream backend-client-api always;
  }

  # Django parity API routing under /api-dj/** (HTTPS)
  location ^~ /api-dj/ {
    proxy_pass http://djangoo_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header Authorization $http_authorization;
    proxy_set_header api-token $http_api_token;
    proxy_set_header x-api-token $http_x_api_token;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
    add_header X-Debug-Upstream djangoo always;
  }
  # --- INTERNAL NEXT API (served by frontend, not backend) ---
  location = /api/users/profile-with-currency { proxy_pass http://backend_upstream; proxy_set_header X-Tenant-Host $host; }
  # Maintenance overlay state (Next.js API route)
  location = /api/dev/maintenance {
    proxy_pass http://frontend_upstream;
    add_header X-Debug-Upstream frontend always;
  }
  location = /api/dev/maintenance-status {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  location = /api/dev/toggle-nginx-maint {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  # Route any /api/dev/* to frontend to avoid backend fallback
  location ^~ /api/dev/ {
    proxy_pass http://frontend_upstream;
    add_header X-Debug-Upstream frontend always;
  }
  location = /api/me { proxy_pass http://frontend_upstream; }
  location = /api/auth/logout { proxy_pass http://frontend_upstream; }
  location = /api/auth/sync { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-orders-count { proxy_pass http://frontend_upstream; }
  location = /api/admin/pending-deposits-count { proxy_pass http://frontend_upstream; }
  ssl_certificate     /etc/nginx/certs/origin.pem;
  ssl_certificate_key /etc/nginx/certs/origin.key;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;
  # Fallback: proxy /api/* to backend if api.wtn4.com subdomain unreachable
  location ^~ /api/ {
    # Preserve original /api/... path so Nest global prefix still matches
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  # Pass tenant host for backend multi-tenant resolution (was missing here)
  proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
  add_header X-Debug-Upstream backend always;
  }
  location / {
    proxy_pass http://frontend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Tenant-Host $host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }
}

# Backend API HTTPS
server {
  listen 443 ssl;
  listen [::]:443 ssl;
  http2 on;
  server_name api.wtn4.com api.watan.games;
  include /opt/nginx-shared/mode.conf;
  # --- Security Headers (API HTTPS) ---
  add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
  add_header Referrer-Policy "strict-origin-when-cross-origin" always;
  add_header Permissions-Policy "camera=(), geolocation=(), microphone=()" always;
  add_header X-Frame-Options "DENY" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-XSS-Protection "0" always;
  add_header Content-Security-Policy "default-src 'none'; frame-ancestors 'none'; base-uri 'none'; form-action 'self';" always;
  # Force dev exemptions early
  if ($uri ~ ^/api/dev/) { set $is_maint_exempt 1; }
  if ($uri ~ ^/dev(/|$)) { set $is_maint_exempt 1; }
  # Maintenance guard (HTTPS api)
  error_page 503 @maintenance;
  set $serve_maintenance 0;
  if ($maintenance_mode != off) { set $serve_maintenance $tenant_maint_target; }
  if ($is_maint_exempt_final = 1)   { set $serve_maintenance 0; }
  if ($is_maint_exempt = 1) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  if ($http_x_maint_bypass ~* ^allow$) { set $serve_maintenance 0; }
  if ($cookie_X_MAINT_BYPASS ~* ^allow$) { set $serve_maintenance 0; }
  # Explicit developer cookie bypass (in addition to map logic in maintenance.conf)
  if ($cookie_X_MAINT_DEV ~* ^allow$) { set $serve_maintenance 0; set $is_maint_exempt_final 1; }
  # Exemptions now handled centrally by $is_maint_exempt map (maintenance.conf)
  if ($serve_maintenance = 1) { return 503; }
  location @maintenance {
    internal;
    root /usr/share/nginx/html;
    add_header Cache-Control "no-store" always;
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
    try_files /maintenance.html =503;
  }
  add_header X-Maint-Mode $maintenance_mode always;
  add_header X-Maint-Exempt $is_maint_exempt always;
  add_header X-Maint-Exempt-Final $is_maint_exempt_final always;
  add_header X-Serve-Maint $serve_maintenance always;
  location = /maintenance.html { root /usr/share/nginx/html; }
  ssl_certificate     /etc/nginx/certs/origin.pem;
  ssl_certificate_key /etc/nginx/certs/origin.key;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;
  # Next.js internal API routes under /api/dev should hit frontend (HTTPS)
  location = /api/dev/maintenance {
    proxy_pass http://frontend_upstream;
    add_header X-Debug-Upstream frontend always;
  }
  location = /api/dev/maintenance-status {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  location = /api/dev/toggle-nginx-maint {
    proxy_pass http://backend_upstream;
    add_header X-Debug-Upstream backend always;
  }
  # Hide upstream CORS headers to avoid duplication (backend also sets them)
  proxy_hide_header Access-Control-Allow-Origin;
  proxy_hide_header Access-Control-Allow-Credentials;
  proxy_hide_header Access-Control-Allow-Methods;
  proxy_hide_header Access-Control-Allow-Headers;
  proxy_hide_header Access-Control-Expose-Headers;
  proxy_hide_header Access-Control-Max-Age;
  # --- Global CORS headers (HTTPS) ---
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
  add_header Access-Control-Expose-Headers "Content-Disposition" always;
  add_header Access-Control-Max-Age 86400 always;
  add_header Vary Origin always;
  # (Debug headers removed)
  # Explicit CORS-preflight + login endpoint handling (HTTPS)
  location = /api/auth/login {
    if ($request_method = OPTIONS) {
      add_header Access-Control-Allow-Origin $cors_allow_origin always;
      add_header Access-Control-Allow-Credentials true always;
      add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
      add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
      add_header Access-Control-Max-Age 86400 always;
      add_header Vary Origin always;
      add_header X-Debug-CORS "login-preflight-https" always;
      return 204;
    }
  # Re-declare CORS headers (inheritance blocked by this location's add_header usage)
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Access-Control-Allow-Credentials true always;
  add_header Access-Control-Allow-Methods "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS" always;
  add_header Access-Control-Allow-Headers "Content-Type,Authorization,X-Tenant-Host,X-Tenant-Id,X-Upload-Correlation,X-Requested-With,Accept,Origin" always;
  add_header Access-Control-Expose-Headers "Content-Disposition" always;
  add_header Access-Control-Max-Age 86400 always;
  add_header Vary Origin always;
  add_header X-Debug-CORS "login-post-https" always;
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Tenant-Host $tenant_origin_host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
  }
  location / {
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
  proxy_set_header X-Tenant-Host $tenant_origin_host;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_cache_bypass $http_upgrade;
    client_max_body_size 15m;
    proxy_request_buffering off;
    proxy_connect_timeout 30s;
    proxy_send_timeout 120s;
    proxy_read_timeout 120s;
    send_timeout 120s;
    proxy_buffering on;
    proxy_buffers 16 16k;
    proxy_busy_buffers_size 24k;
  if ($request_method = OPTIONS) { return 204; }
  proxy_set_header Origin $http_origin;
  }
}

# Fallback unknown hosts
server {
  listen 80 default_server;
  return 444;
}
